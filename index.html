<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>QR Word Match</title>
	<meta name="color-scheme" content="dark light">
	<style>
		:root { --bg:#0b0d12; --fg:#f7f7f7; --muted:#a8b0bd; --ok:#1cc88a; --bad:#ff5d5d; }
		* { box-sizing: border-box; }
		body { margin: 0; padding: 0; background: var(--bg); color: var(--fg);
			font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
			display: grid; min-height: 100vh; grid-template-rows: auto 1fr auto; }
		header, footer { padding: 12px 16px; background: #0f131a; border-bottom: 1px solid #151a22; }
		header h1 { margin: 0; font-size: 18px; letter-spacing: .4px; }
		main { padding: 14px; display: grid; gap: 12px; align-content: start; }
		.card { background: #111722; border: 1px solid #1c2432; border-radius: 14px; padding: 12px; display: grid; gap: 10px; }
		button, select, .pill {
			background: #1a2230; color: var(--fg); border: 1px solid #2a3548; border-radius: 10px;
			padding: 10px 14px; font-size: 16px; cursor: pointer;
		}
		button:active { transform: translateY(1px); }
		.word { font-size: clamp(28px, 7vw, 60px); text-align: center; font-weight: 800; letter-spacing: .8px;
			padding: 12px 10px; border-radius: 12px; background: #0f1520; border: 1px dashed #25324a; }
		.status { text-align: center; font-weight: 700; min-height: 1.2em; }
		.status.ok { color: var(--ok); } .status.bad { color: var(--bad); }
		#reader { width: 100%; max-width: 560px; margin: 0 auto; border-radius: 12px; overflow: hidden;
			border: 1px solid #283449; background: #0a0f16; position: relative; aspect-ratio: 1/1; }
		video { width: 100%; height: 100%; object-fit: cover; }
		canvas { position:absolute; inset:0; width:100%; height:100%; pointer-events:none; }
		.small { color: var(--muted); font-size: 12px; }
		.row { display: flex; gap: 8px; flex-wrap: wrap; align-items:center; }
		.tag { font-size: 12px; color: var(--muted); background:#0d1420; border:1px solid #1f2a3d; padding:6px 8px; border-radius:999px;}
		.selects { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
		#refreshCams { padding-inline: 10px; }
		.toggle { display:flex; gap:6px; background:#0d1420; border:1px solid #1f2a3d; padding:6px; border-radius:999px; }
		.toggle label { padding:6px 10px; border-radius:999px; cursor:pointer; user-select:none; }
		.toggle input { display:none; }
		.toggle input:checked + span { background:#1a2230; border:1px solid #2a3548; }
	</style>
</head>
<body>
	<header><h1>QR Word Match</h1></header>
	<main>
		<div class="card">
			<div class="row" style="justify-content:space-between;">
				<div class="row">
					<button id="startBtn">Start camera</button>
					<button id="stopBtn" disabled>Stop</button>
					<button id="nextBtn">New word</button>
				</div>
				<div class="selects">
					<!-- Works when device IDs are available -->
					<select id="cameraSel" title="Choose camera">
						<option value="">(choose camera)</option>
					</select>
					<button id="refreshCams" type="button" title="Refresh camera list">â†»</button>
					<!-- Always works: explicit facingMode toggle -->
					<div class="toggle" title="Force front/back camera">
						<label><input type="radio" name="face" value="environment" checked><span>Back</span></label>
						<label><input type="radio" name="face" value="user"><span>Front</span></label>
					</div>
					<select id="mode">
						<option value="exact" selected>Exact match</option>
						<option value="loose">Ignore accents & case</option>
					</select>
				</div>
			</div>
			<div id="currentWord" class="word" aria-live="polite">gato</div>
			<div class="status" id="status"></div>
			<div id="reader">
				<video id="video" playsinline muted></video>
				<canvas id="overlay"></canvas>
			</div>
			<div class="row">
				<div class="tag" id="scoreTag">Score: 0</div>
				<div class="tag" id="streakTag">Streak: 0 ðŸ”¥</div>
				<div class="tag" id="camInfo">Cameras: ?</div>
			</div>
			<div id="err" class="small" style="color:#ff8c8c;"></div>
			<p class="small">Tip: On iOS, camera names show up only after you grant access once. If the list is empty, use the Front/Back toggle.</p>
		</div>

		<div class="card">
			<strong>Word list</strong>
			<p class="small">Edit below to customize. One word per line.</p>
			<textarea id="wordList" rows="6" style="width:100%; background:#0f1520; color:var(--fg); border:1px solid #25324a; border-radius:10px; padding:10px; font-size:15px;">gato
ratÃ³n
castillo
elefante
perro
tres</textarea>
			<div class="row">
				<button id="saveWords">Save list</button>
				<span class="small">Saved to your browser.</span>
			</div>
		</div>
	</main>
	<footer><span class="small">Use over HTTPS for camera access. iOS reveals camera names after permission.</span></footer>

	<script>
	// --- UI elements
	const wordEl = document.getElementById('currentWord');
	const statusEl = document.getElementById('status');
	const startBtn = document.getElementById('startBtn');
	const stopBtn = document.getElementById('stopBtn');
	const nextBtn = document.getElementById('nextBtn');
	const modeSel = document.getElementById('mode');
	const wordListTA = document.getElementById('wordList');
	const saveWordsBtn = document.getElementById('saveWords');
	const scoreTag = document.getElementById('scoreTag');
	const streakTag = document.getElementById('streakTag');
	const cameraSel = document.getElementById('cameraSel');
	const refreshBtn = document.getElementById('refreshCams');
	const faceRadios = document.querySelectorAll('input[name="face"]');
	const camInfo = document.getElementById('camInfo');
	const errEl = document.getElementById('err');
	const video = document.getElementById('video');
	const overlay = document.getElementById('overlay');
	const ctx = overlay.getContext('2d');

	// --- State
	const LS_KEY = "qr-word-game:list";
	const LS_CAM = "qr-word-game:camera-id";
	const LS_FACE = "qr-word-game:facing";
	let words = loadWords();
	let score = 0, streak = 0;
	let scanning = false;
	let stream = null;
	let detector = null;
	let rafId = null;
	let lastText = null;

	// --- Helpers
	function loadWords(){
		const saved = localStorage.getItem(LS_KEY);
		if(saved) wordListTA.value = saved;
		return wordListTA.value.split(/[\r\n]+/).map(s=>s.trim()).filter(Boolean);
	}
	function saveWords(){
		localStorage.setItem(LS_KEY, wordListTA.value);
		words = loadWords();
		toast("Saved!");
	}
	saveWordsBtn.addEventListener('click', saveWords);

	function randomWord(){
		if(words.length === 0){ words = ["gato"]; }
		const i = Math.floor(Math.random()*words.length);
		return words[i];
	}
	function setWord(w){
		wordEl.textContent = w;
		statusEl.textContent = "";
		statusEl.className = "status";
	}
	setWord(randomWord());

	function normalize(s){
		if(modeSel.value === "exact") return s.trim();
		return s.normalize("NFD").replace(/\\p{Diacritic}/gu,"").toLowerCase().trim();
	}

	function celebrate(){
		const bursts = 40;
		for (let i=0;i<bursts;i++) {
			const d = document.createElement('div');
			const size = 6 + Math.random()*6;
			d.style.cssText = `position:fixed;left:${Math.random()*100}vw;top:0; width:${size}px;height:${size}px;background:hsl(${Math.random()*360} 90% 60%);opacity:.9;transform:translateY(-20px);border-radius:2px;transition:transform 1s ease-out, opacity 1s ease-out;z-index:9999`;
			document.body.appendChild(d);
			requestAnimationFrame(()=>{
				d.style.transform = `translateY(${60+Math.random()*40}vh) rotate(${Math.random()*720}deg)`;
				d.style.opacity = '0';
			});
			setTimeout(()=> d.remove(), 1100);
		}
	}
	function updateScore(ok){
		if(ok){ score += 1; streak += 1; } else { streak = 0; }
		scoreTag.textContent = "Score: " + score;
		streakTag.textContent = "Streak: " + streak + " ðŸ”¥";
	}

	function looksLikeBack(label = "") {
		const s = (label||"").toLowerCase();
		return s.includes("back") || s.includes("rear") || s.includes("environment") || s.includes("traseira");
	}

	function getFacing() {
		const saved = localStorage.getItem(LS_FACE);
		if (saved) {
			for (const r of faceRadios) if (r.value === saved) r.checked = true;
		}
		const r = Array.from(faceRadios).find(r => r.checked);
		return r ? r.value : "environment";
	}

	// Robust camera enumeration with virtual fallback
	async function enumerateCameras() {
		try {
			const devices = await navigator.mediaDevices.enumerateDevices();
			const vids = devices.filter(d => d.kind === "videoinput");

			cameraSel.innerHTML = "";
			if (vids.length > 0) {
				for (let i = 0; i < vids.length; i++) {
					const c = vids[i];
					const opt = document.createElement("option");
					opt.value = c.deviceId || "";
					opt.textContent = c.label || `Camera ${i + 1}`;
					cameraSel.appendChild(opt);
				}
				const saved = localStorage.getItem(LS_CAM);
				if (saved && [...cameraSel.options].some(o => o.value === saved)) {
					cameraSel.value = saved;
				} else {
					const backIdx = [...cameraSel.options].findIndex(o => /\\b(back|rear|environment)\\b/i.test(o.textContent));
					cameraSel.selectedIndex = backIdx >= 0 ? backIdx : 0;
				}
			} else {
				// keep placeholder; user will use Front/Back toggle
				cameraSel.innerHTML = "<option value=''> (choose camera) </option>";
			}
			camInfo.textContent = "Cameras: " + vids.length;
		} catch (e) {
			cameraSel.innerHTML = "<option value=''> (choose camera) </option>";
			camInfo.textContent = "Cameras: ?";
		}
	}

	async function start(){
		if (scanning) return;

		if ('BarcodeDetector' in window) {
			try { detector = new BarcodeDetector({ formats: ['qr_code'] }); }
			catch(e){ errEl.textContent = "BarcodeDetector init failed: " + e.message; }
		} else {
			errEl.textContent = "BarcodeDetector not supported in this browser.";
		}

		if (!cameraSel.options.length) { await enumerateCameras(); }

		let constraints;
		const val = cameraSel.value;
		const face = getFacing();
		if (val) {
			// try deviceId first (if available)
			constraints = { audio: false, video: { deviceId: { exact: val } } };
		} else {
			// no deviceId â†’ use facingMode
			constraints = { audio: false, video: { facingMode: { exact: face } } };
		}

		try {
			stream = await navigator.mediaDevices.getUserMedia(constraints);
		} catch(e){
			// fallback: if deviceId failed, try facingMode
			if (val) {
				try {
					stream = await navigator.mediaDevices.getUserMedia({ audio:false, video:{ facingMode: { exact: face } } });
					cameraSel.value = "";
				} catch (e2) {
					errEl.textContent = "getUserMedia error: " + e2.message;
					return;
				}
			} else {
				errEl.textContent = "getUserMedia error: " + e.message;
				return;
			}
		}

		// remember face selection
		localStorage.setItem(LS_FACE, face);

		// remember deviceId when available
		try {
			const settings = stream.getVideoTracks()[0]?.getSettings?.() || {};
			if (settings.deviceId) localStorage.setItem(LS_CAM, settings.deviceId);
		} catch {}

		video.srcObject = stream;
		await video.play();

		function resize(){
			const r = document.getElementById('reader').getBoundingClientRect();
			overlay.width = r.width * devicePixelRatio;
			overlay.height = r.height * devicePixelRatio;
			ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
		}
		resize(); addEventListener('resize', resize);

		scanning = true;
		startBtn.disabled = true; stopBtn.disabled = false; nextBtn.disabled = true;

		// After permission, iOS can reveal labels/IDsâ€”refresh
		setTimeout(enumerateCameras, 200);

		scanLoop();
	}

	function stop(){
		if (!scanning) return;
		cancelAnimationFrame(rafId);
		if (stream) { for (const t of stream.getTracks()) t.stop(); stream = null; }
		scanning = false;
		startBtn.disabled = false; stopBtn.disabled = true; nextBtn.disabled = false;
		ctx.clearRect(0,0,overlay.width, overlay.height);
	}

	async function scanLoop(){
		if (!scanning) return;
		try {
			if (detector) {
				const dets = await detector.detect(video);
				if (dets && dets.length) {
					ctx.clearRect(0,0,overlay.width, overlay.height);
					for (const d of dets) {
						const box = d.boundingBox;
						ctx.strokeStyle = "rgba(0,255,180,.9)";
						ctx.lineWidth = 3;
						ctx.strokeRect(box.x, box.y, box.width, box.height);
						const txt = d.rawValue || "";
						if (txt && txt !== lastText) {
							lastText = txt;
							checkText(txt);
						}
					}
				} else {
					ctx.clearRect(0,0,overlay.width, overlay.height);
				}
			}
		} catch(e){
			errEl.textContent = "detect error: " + (e.message || e);
		}
		rafId = requestAnimationFrame(scanLoop);
	}

	function checkText(decodedText){
		const target = wordEl.textContent;
		const ok = normalize(decodedText) === normalize(target);
		updateScore(ok);
		if(ok){
			statusEl.textContent = "âœ” Correct: " + decodedText;
			statusEl.className = "status ok";
			celebrate();
			setTimeout(()=> setWord(randomWord()), 900);
		}else{
			statusEl.textContent = "âœ– Not matched: " + decodedText;
			statusEl.className = "status bad";
		}
	}

	startBtn.addEventListener('click', start);
	stopBtn.addEventListener('click', stop);
	nextBtn.addEventListener('click', ()=> setWord(randomWord()));
	cameraSel.addEventListener('change', async () => {
		localStorage.setItem(LS_CAM, cameraSel.value);
		if (scanning) { stop(); start(); }
	});
	refreshBtn.addEventListener('click', enumerateCameras);
	faceRadios.forEach(r => r.addEventListener('change', () => {
		localStorage.setItem(LS_FACE, getFacing());
		if (scanning) { stop(); start(); }
	}));

	function toast(msg){
		const el = document.createElement('div');
		el.textContent = msg;
		el.style.cssText = "position:fixed;bottom:16px;left:50%;transform:translateX(-50%);background:#111722;border:1px solid #1c2432;padding:8px 12px;border-radius:999px;color:var(--fg);box-shadow:0 8px 30px rgba(0,0,0,.4);z-index:9999";
		document.body.appendChild(el);
		setTimeout(()=> el.remove(), 1200);
	}

	// Error surfacing
	addEventListener('error', e => errEl.textContent = 'Error: ' + (e.error?.message || e.message || e.filename));
	addEventListener('unhandledrejection', e => errEl.textContent = 'Promise error: ' + (e.reason?.message || e.reason));

	// Initial setup
	enumerateCameras();
	// Restore facing selection
	getFacing();

	// Keep screen awake on supported browsers
	if ("wakeLock" in navigator) {
		let lock = null;
		document.addEventListener('visibilitychange', async () => {
			if (document.visibilityState === "visible" && scanning) {
				try { lock = await navigator.wakeLock.request("screen"); } catch {}
			} else if (lock) { try { lock.release(); } catch {} }
		});
	}
	</script>
</body>
</html>
